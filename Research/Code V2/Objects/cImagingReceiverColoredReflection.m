classdef cImagingReceiverColoredReflection < cImagingReceiver
    methods
        % Constructor
        function obj = cImagingReceiverColoredReflection(Xr,Yr,Zr,Xs,Ys,f,fN)
            % cImagingReceiver(Xr,Yr,Zr,Xs,Ys,f,fN): Class constructor
            % Xr,Yr,Zr: X,Y,Z coord of receiver locations. Default (0,0,0)
            % Xs,Ys: X,Y coord of center of pixel in local coord
            % f,fN: focal length, aperture f/#
            obj = obj@cImagingReceiver(Xr,Yr,Zr,Xs,Ys,f,fN);
        end
    end
    methods
%         function [Ipx Iambpx Isig Iamb frSpOnPx frPxOnSp] = ...
%                 getSignal(obj,rxPSD,ambPSD,txLoc,txSz)
          function [Ipx Iambpx Isig Iamb frSpOnPx frPxOnSp] = ...
                getSignal(varargin)
            % [Isig Ipx] = getSignal(rxPSD,txLoc,txSz)
            % calculates and returns current generated by the
            % incident irradiance
            % -INPUT-
            % rxPSD: incident power spectral density (cPSD) array
            % txLoc: transmitter locations array
            % txSz: transmitter size array
            %
            % -OUTPUT-
            % Isig: current generated by the incident irradiance from each
            % transmit channel
            % Ipx: current generated by each pixel due to the incident irradiance
            obj = varargin{1};
            rxPSD = varargin{2};
            ambPSD = varargin{3};
            txLoc = varargin{4};
            txSz = varargin{5};
            txOri = varargin{6};
            if ~isa(rxPSD,'cPSD')
                error('Input argument ''rxPSD'' must be of type ''cPSD''');
            end
            if ~isa(txLoc,'cLocation')
                error('Input argument ''txLoc'' must be of type ''cLocation''');
            end
            if ~isa(txSz,'cSize')
                error('Input argument ''txSz'' must be of type ''cSize''');
            end
            nR = obj.rxCount;
            nP = obj.sensor.location.count;
            nT = numel(txLoc.X);
            nC = max(obj.sensor.type(:));
            % Calculate Received Image
            % [spX1 spY1 spX2 spY2 spX3 spY3 spX4 spY4] =...
            %    getRcvImg(txLoc.X,txLoc.Y,txLoc.Z,...
            %     obj.location.X,obj.location.Y,obj.location.Z,...
            %     txSz.L,obj.optics.f);
            [spX1 spY1 spX2 spY2 spX3 spY3 spX4 spY4] =... 
                obj.getImage(obj.location,txLoc,txSz,txOri);
            
            % Calculate amount of spot overlap (if any)
            gdDel = 100;
            frSpOnPx = zeros(nR,nT,nP);
            frPxOnSp = zeros(nR,nT,nP);
            for idRx = 1:nR
                [frSpOnPx(idRx,:,:) frPxOnSp(idRx,:,:)] = getPixelvSpot(...
                    spX1(idRx,:),spY1(idRx,:),spX2(idRx,:),spY2(idRx,:),...
                    spX3(idRx,:),spY3(idRx,:),spX4(idRx,:),spY4(idRx,:),...
                    obj.sensor.pxR,obj.sensor.pxT,...
                    obj.sensor.pxL,obj.sensor.pxT,...
                    obj.sensor.pxL,obj.sensor.pxB,...
                    obj.sensor.pxR,obj.sensor.pxB,...
                    gdDel,gdDel);
            end
            A = obj.optics.Area;
            Ipx = zeros(nR,nP);
            Isig = zeros(nR,nT,nC);
            Iambpx = zeros(nR,nP);
            Iamb = zeros(nR,nT,nC);
            % for each receiver location
            for iR = 1:nR
                % for each pixel
                for iP = 1:nP
                    iC = obj.sensor.type(iP);
                    % get responsivity of pixel
                    R = obj.sensor.responsivity(iP);
                    % get filter of pixel
                    F = obj.sensor.filter(iP);
                    % area of pixel
                    Ap = obj.sensor.edge.A;
                    % take PSD of ambient light
                    psd = ambPSD(iR);
                    Pl = psd.rdFlux;
                    % filter PSD based on pixel
                    psdF = (psd.npsd).*F;
                    % dot prod with responsivity
                    Isp = psdF.*R;
                    % integrate and add to get current for each pixel
                    Iambpx(iR,iP) = Pl*A*Isp.getIntegral()*obj.sensor.dimension.A(iP)/Ap;
                    % for each spot
                    for iT = 1:nT
                        % get amount of each spot on pixel
                        fr = frSpOnPx(iR,iT,iP);
                        if(fr > 0)
                            % take PSD of that spot
                            psd = rxPSD(iR,iT);
                            Pl = psd.rdFlux;
                            % filter PSD based on pixel
                            psdF = (psd.npsd).*F;
                            % dot prod with responsivity
                            Isp = psdF.*R;
                            % integrate and add to get current for each pixel
                            Ipx(iR,iP) = Ipx(iR,iP) + fr*Pl*A*Isp.getIntegral();
                            Isig(iR,iT,iC) = Isig(iR,iT,iC) + Ipx(iR,iP);
                            Iamb(iR,iT,iC) = Iamb(iR,iT,iC) + Iambpx(iR,iP);
                        end
                    end
                end
            end
        end
    end
end