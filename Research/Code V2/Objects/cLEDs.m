classdef cLEDs < handle
    % class to handle Multicolored LED
    properties(SetAccess = immutable)
        PSDs;   % PSDs for each color forming the MC-LED
        Txyz;   % LEDs2XYZ transformation matrix
        obs;    % Standard observer (CIE XYZ 1978)
        flRes;  % color flux normalized increment resolution
        NCLR;   % Number of colors
    end
    
    properties(SetAccess = private)
        tn;     % tristimulus values
        xyz;    % SPD XY coordinate on CIE 1978
        hWB;    % handle waitbar
        %         cct;    % correlated color temperature for each xyz(:,i) combination. using mccamy's formula. More accurate
    end
    
    methods
        % destructor
        function delete(obj)
            if ishandle(obj.hWB)
                delete(obj.hWB);
            end
        end
        
        % constructor
        function obj = cLEDs(varargin)
            obj.PSDs = {};
            obj.NCLR = 0;
            for i=1:nargin
                o = varargin{i};
                if isa(o,'cPSD')
                    obj.PSDs{end+1} = o;
                    obj.NCLR = obj.NCLR + 1;
                elseif isnumeric(o)
                    Res = o;
                elseif ischar(o)
                    flCIE = o;
                end
            end
            % normalized optical flux resolution (between 0 and 1)
            if ~exist('Res','var')
                Res = 0.1;
            end
            if (Res>0) && (Res<=1)
                obj.flRes = Res;
            else
                error('''flRes'' must be a scalar value between 0 and 1');
            end
            
            % Generate CIE 1978 object
            if ~exist('flCIE','var')
                flCIE = 'CIE1931_JV_1978_2deg.csv';
            end
            obj.obs = cCIE(flCIE);
            % initialize variables
            obj.tn = nan(obj.NCLR,1); obj.xyz = nan(3,1);
            % initialize Txyz
            obj.Txyz = obj.getRGB2XYZ();
            % scale fluxes
            [xm,ym] = obj.getMedianXY();
            Ti = obj.Txyz\[xm;ym;1-xm-ym];
            for i=1:obj.NCLR
                p = obj.PSDs{i};
                p.scaleOutputFlux(Ti(i)*obj.NCLR);
            end
            % re-compute Txyz
            obj.Txyz = obj.getRGB2XYZ();
        end
        
        % initialize the class
        function initialize(obj)
            Z0 = 1/obj.NCLR; A0 = 0; D0 = (Z0-A0)*obj.flRes*2;
            Z1 = 1; D1 = (Z1-Z0)*obj.flRes*2; A1 = Z0+D1;
            res = [A0:D0:Z0 A1:D1:Z1];
            resLEN = numel(res);
            
            s = zeros(obj.NCLR,1);
            IDX = ones(obj.NCLR,1);
            h = waitbar(0,'0.00%','Name','Characterizing LED...',...
                'CreateCancelBtn',...
                'setappdata(gcbf,''canceling'',1)');
            try
                setappdata(h,'canceling',0);
                TOTALLOOPS = resLEN.^obj.NCLR;
                LOOPCOUNT = 0;
                run = true;
                while run
                    s = res(IDX)';
                    ttn = s/sum(s,1);
                    if ~ismember(obj.tn',ttn','rows')
                        XYZ = obj.Txyz*ttn;
                        obj.tn(:,end+1) = ttn;
                        obj.xyz(:,end+1) = XYZ/sum(XYZ,1);
                    end
                    LOOPCOUNT = LOOPCOUNT + 1;
                    PROG = LOOPCOUNT/TOTALLOOPS;
                    waitbar(PROG,h,sprintf('%0.2f%% done...',PROG*100));
                    if(getappdata(h,'canceling'))
                        delete(h);
                        error('Characterization aborted');
                    end
                    
                    IDX(1) = IDX(1) + 1;
                    for i=1:obj.NCLR
                        if IDX(i) > resLEN
                            IDX(i) = 1;
                            if i == obj.NCLR
                                run = false;
                            else
                                IDX(i+1) = IDX(i+1) + 1;
                            end
                        end
                    end
                end
                waitbar(1);
            catch ex
                delete(h);
                rethrow(ex);
            end
            delete(h);
        end
        
        % get PSD generated by the RGB led closest to x,y CIE point
        function [S,Ds,Ts] = getPSD(obj,x,y)
            P = repmat([x;y;1-x-y],1,size(obj.xyz,2));
            vP = obj.xyz-P;
            dP = sum(vP.*vP,1);
            Ts = obj.tn(:,find(dP==min(dP),1,'first'));
            Ds = {};
            for i=1:obj.NCLR
                Ds{i} = Ts(i)*obj.PSDs{i};
                if i==1
                    S = Ds{i};
                else
                    S = S + Ds{i};
                end
            end
        end
        
    end % methods
    
    methods(Access = private)
        % compute RGB2XYZ transformation matrix
        function T = getRGB2XYZ(obj)
            T = zeros(obj.NCLR,3);
            for i=1:obj.NCLR
                p = obj.PSDs{i};
                [T(1,i),T(2,i),T(3,i)] = obj.obs.getTristimulusValues(p.npsd*p.rdFlux);
            end
        end % getRGB2XYZ
        
        % compute median [x,y]
        function [xm,ym] = getMedianXY(obj)
            T = obj.getRGB2XYZ();
            xm=0;ym=0;
            for i=1:obj.NCLR
                X = T(1,i);Y = T(2,i);Z = T(3,i);
                SM = X+Y+Z;
                x=X/SM;y=Y/SM;
                xm=xm+x;ym=ym+y;
            end
            xm=xm/obj.NCLR;ym=ym/obj.NCLR;
        end % getMedianXY
        
    end % methods(Access = private)
end % classdef














