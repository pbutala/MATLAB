classdef cImagingReceiverWhiteReflection < cImagingReceiver
    methods
        % Constructor
        function obj = cImagingReceiverWhiteReflection(Xr,Yr,Zr,Xs,Ys,f,fN)
            % cImagingReceiver(Xr,Yr,Zr,Xs,Ys,f,fN): Class constructor
            % Xr,Yr,Zr: X,Y,Z coord of receiver locations. Default (0,0,0)
            % Xs,Ys: X,Y coord of center of pixel in local coord
            % f,fN: focal length, aperture f/#
            obj = obj@cImagingReceiver(Xr,Yr,Zr,Xs,Ys,f,fN);
        end
    end
    
    %% Overloaded methods
    methods
%         function [Ipx Iambpx Isig Iamb frSpOnPx frPxOnSp] = ...
%                 getSignal(obj,rxPSD,rxH,ambPSD,txLoc,txSz)
        function [Ipx Iambpx Isig Iamb frSpOnPx frPxOnSp Hch] = ...
                getSignal(varargin)
            % [Isig Ipx] = getSignal(rxPSD,txLoc,txSz)
            % calculates and returns current generated by the
            % incident irradiance
            % -INPUT-
            % rxPSD: incident power spectral density (cPSD) array
            % txLoc: transmitter locations array
            % txSz: transmitter size array
            % rxH: channel gain (rx,tx) EXPECT 2D MATRIX FOR THIS CLASS
            % -OUTPUT-
            % Isig: current generated by the incident irradiance from each
            % transmit channel
            % Ipx: current generated by each pixel due to the incident irradiance
            obj = varargin{1};
            rxPSD = varargin{2};
            rxH = varargin{3};
            ambPSD = varargin{4};
            txLoc = varargin{5};
            txSz = varargin{6};
            txOri = varargin{7};
            if ~isa(rxPSD,'cPSD')
                error('Input argument ''rxPSD'' must be of type ''cPSD''');
            end
            if ~isa(txLoc,'cLocation')
                error('Input argument ''txLoc'' must be of type ''cLocation''');
            end
            if ~isa(txSz,'cSize')
                error('Input argument ''txSz'' must be of type ''cSize''');
            end
            nR = obj.rxCount;
            nP = obj.sensor.location.count;
            nT = numel(txLoc.X);
            nC = max(obj.sensor.type(:));
            % Calculate Received Image
            % [spX1 spY1 spX2 spY2 spX3 spY3 spX4 spY4] =...
            %     getRcvImg(txLoc.X,txLoc.Y,txLoc.Z,...
            %    obj.location.X,obj.location.Y,obj.location.Z,...
            %    txSz.L,obj.optics.f);
            [spX1 spY1 spX2 spY2 spX3 spY3 spX4 spY4] =... 
                obj.getImage(obj.location,txLoc,txSz,txOri);
            
            % Calculate amount of spot overlap (if any)
            gdDel = 100;
            frSpOnPx = zeros(nR,nT,nP);
            frPxOnSp = zeros(nR,nT,nP);
            Hch = zeros(nR,nT,nP);
            for idRx = 1:nR
                [frSpOnPx(idRx,:,:) frPxOnSp(idRx,:,:)] = getPixelvSpot(...
                    spX1(idRx,:),spY1(idRx,:),spX2(idRx,:),spY2(idRx,:),...
                    spX3(idRx,:),spY3(idRx,:),spX4(idRx,:),spY4(idRx,:),...
                    obj.sensor.pxR,obj.sensor.pxT,...
                    obj.sensor.pxL,obj.sensor.pxT,...
                    obj.sensor.pxL,obj.sensor.pxB,...
                    obj.sensor.pxR,obj.sensor.pxB,...
                    gdDel,gdDel);
            end
            A = obj.optics.Area;                        % Aperture Area
            Pl = rxPSD.rdFlux*rxH*obj.optics.T;         % received flux * optics transmission
            RF = obj.sensor.getResponsivityFiltered();  % filtered responsivities
            RCh = zeros(size(obj.sensor.location.X));   
            Ipx = zeros(nR,nP);
            Isig = zeros(nR,nT,nC);
            Iambpx = zeros(nR,nP);
            Iamb = zeros(nR,nT,nC);
            for iP = 1:nP
                r = rxPSD.npsd.*RF(iP);
                RCh(iP) = r.getIntegral();
                r = ambPSD.npsd.*RF(iP);
                Iambpx(:,iP) = ambPSD.rdFlux*r.getIntegral()*obj.sensor.dimension.A(iP)/obj.sensor.edge.A;
            end
            % for each receiver location
            for iR = 1:nR
                % for each pixel
                for iP = 1:nP
                    iC = obj.sensor.type(iP);
                    % for each spot
                    for iT = 1:nT
                        % get amount of each spot on pixel
                        fr = frSpOnPx(iR,iT,iP);
                        if(fr > 0)
                            sig = fr*Pl(iR,iT)*A*RCh(iP);
                            Hch(iR,iT,iP) = fr*rxH(iR,iT)*obj.optics.T*A*RCh(iP);
                            Ipx(iR,iP) = Ipx(iR,iP) + sig;
                            Isig(iR,iT,iC) = Isig(iR,iT,iC) + sig;
                            Iamb(iR,iT,iC) = Iamb(iR,iT,iC) + Iambpx(iR,iP);
                        end
                    end
                end
            end
        end
    end
end